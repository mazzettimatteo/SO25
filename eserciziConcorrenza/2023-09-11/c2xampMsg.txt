Esercizio c.2: Un servizio di message passing asincrono esteso (XAMP) fornisce 4 chiamate:
• void xsend(msg_t msg, pid_t pid): spedisce il messaggio msg al processo pid
• msg_t xrecv(pid_t pid): riceve un messaggio da pid (o da chiuque se pid==0). E' una receive completamente
asincrona: se non c'è nessun messaggio da pid (o da chiunque se pid==0), xrecv restituisce NULL, non attende.
• int xcount(pid_t pid): ritorna il numero di messaggi in attesa di essere ricevuti provenienti da pid (o da
chiunque se pid==0).
• void xexpect(pid_t pid): attende che vi sia almeno un messaggio in attesa di essere ricevuto proveniente da
pid (o da chiunque se pid==0). Se un tale elemento esiste al momento della chiamata, xexpect non è
bloccante.
Il servizio XAMP ha lo stesso potere espressivo del message passing asincrono? (quello definito a lezione).

Devo dimostrare XAMP se, e solo se, ASYNC

Da XAMP a ASYNC:
void asend(msg_t msg, pid_t pid){
    xsend(msg, pid)
}

msg_t arecv(pid_t snd){
    msg_t incoming
    if(snd==0){
        xexpect(ANY)
        incoming=xrecv(ANY)
    }
    else{
        xexpect(snd)
        incoming=xrecv(snd)
    }
    return incoming
}

Da ASYNC a XAMP:
void xsend(msg_t msg, pid_t pid){
    asend(<msg,getpid()>, pid)
}

/* msg_t xrecv(pid_t pid): riceve un messaggio da pid (o da chiuque se pid==0). E' una receive completamente
asincrona: se non c'è nessun messaggio da pid (o da chiunque se pid==0), xrecv restituisce NULL, non attende */
buffer buf[]
msg_t xrecv(pid_t snd){
    while(true){
        asend(<NULL,getpid()>,getpid())
        incoming=arecv(ANY)
        if(incoming.pid==getpid()) return NULL
        else{
            buf.add(incoming.msg)
            if(incoming.pid==snd){
                return incoming.msg
            }
        }
    }
}

/* int xcount(pid_t pid): ritorna il numero di messaggi in attesa di essere ricevuti provenienti da pid (o da
chiunque se pid==0).*/

buffer buf[]
int xcount(pid_t snd){
    int contANY=0
    int contSND=0
    while(true){
        asend(<NULL,getpid()>,getpid())
        incoming=arecv(ANY)
        contANY++
        if(incoming.pid==getpid()) {
            contANY--
        }
        else{
            buf.add(incoming.msg)
            if(incoming.pid==snd){
                contSND++
            }
        }
    }
    result= snd==0 ? contANY : contSND     
}

/*void xexpect(pid_t pid): attende che vi sia almeno un messaggio in attesa di essere ricevuto proveniente da
pid (o da chiunque se pid==0). Se un tale elemento esiste al momento della chiamata, xexpect non è
bloccante.*/

void xexpect(pid_t snd){
    if(snd==0){
        _=arecv(ANY)
    }
    else{
        _=arecv(snd)
    }
}