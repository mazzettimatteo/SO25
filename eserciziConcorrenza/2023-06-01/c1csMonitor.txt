Esercizio c.1: Scrivere il monitor cs che fornisca un servizio di elaborazione client-server.
I molteplici "clienti" chiedono elaborazioni ai server eseguendo la seguente funzione:
def service_request(data):
 return cs.request(data)
mentre i server eseguono il codice:
process server(i: i = 0,...,NSERVER-1):
 while True:
   data = cs.get_request(i)
   cs.send_result(i, process(data))
Quando un server è libero chiede una nuova richiesta da elaborare (funzione get_request), se non ci sono richieste da
elaborare attende che un cliente ne sottoponga una (tramite la funzione request). Se vi sono uno o più richieste in attesa
di essere elaborate get_request restituisce i dati (argomento data) della prima.
Dopo che il server ha elaborato la richiesta (funzione process) il risultato viene passsato al monitor tramite la funzione
send_result che lo restituisce al cliente come valore di ritorno della funzione request

monitor cs:

struct Request{obj data, obj result, condition done}
queue of Request Q
condition newReqMade
Request reqs[NSERVER] //richieste in elaborazione

obj request(data){
  r=new Request() //creo una nuova richiesta, fornendo i dati iniziali, mettendola in coda e mettendola poi in attesa di completamento
  r.data=data
  r.condition=new condition()
  Q.enqueue(r)
  newReqMade.signal()
  r.condition.wait()
  return r.result 
}
obj get_request(int i){
  if(Q.isEmpty()){  //se non ci sono richieste attendi
    newReqMade.wait()
    r=Q.dequeue() //prendi la prima richiesta fatta
    reqs[i]=r //mettila in elaborazione
  }
  return r.data
}
void send_result(int i, obj data){
  reqs[i].result=data //metti il risultato dell'elaborazione nella richiesta giusta
  reqs[i].condition.signal() //avvisa che hai completato la richiesta
}